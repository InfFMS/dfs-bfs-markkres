# Даны N городов и M дорог между ними. Дороги двусторонние (граф неориентированный). 
# Известно, что города разделены на группы (острова), 
# между которыми дорог нет. То есть граф состоит из нескольких компонент связности (островов). 
# Необходимо ответить на следующие вопросы:
# 
# 1. Есть ли путь между двумя заданными городами (вершинами)?
# 2. Сколько всего островов (компонент связности) в графе?
# 3.Перечислить, какие города принадлежат каждому острову.
# 
# Входные данные:
# Первая строка: N (количество городов) и M (количество дорог).
# Следующие M строк: пары чисел u и v, обозначающие дорогу между городами u и v.
# Затем вводится два числа: start и end — номера городов, между которыми нужно проверить наличие пути.
# 
# Выходные данные:
# Ответ на вопрос, есть ли путь между start и end ("YES" или "NO").
# Количество островов (компонент связности) в графе.
# Список городов для каждого острова (в порядке возрастания номеров островов).

# Пример 1:
# 5 3
# 1 2
# 2 3
# 4 5
# 1 4
# 
# Ожидаемый вывод:
# 
# NO
# 2
# 1: [1, 2, 3]
# 2: [4, 5]

# Пример 2:
# 6 4
# 1 2
# 3 4
# 5 6
# 2 3
# 3 5
# 
# Ожидаемый вывод:
# 
# YES
# 1
# 1: [1, 2, 3, 4, 5, 6]

# Пример 3:
# 7 0
# 1 2
# 
# Ожидаемый вывод:
# 
# NO
# 7
# 1: [1]
# 2: [2]
# 3: [3]
# 4: [4]
# 5: [5]
# 6: [6]
# 7: [7]
def DFS(graph,start,visited=None):
    if visited is None:
        visited=set()
    visited.add(start)
    poddelca.append(start)
    for i in graph.get(start,[]):
        if i not in visited:
            DFS(graph,i,visited)
    return visited

N,M=map(int,input().split())
Dict={i:[] for i in range(1,N+1)}
#print(Dict)
for _ in range(M):
    a,b=map(int,input().split())
    Dict[a].append(b)
    Dict[b].append(a)
#print(Dict)

mas=[]
poddelca=[]
DFS(Dict,1)
mas.append(poddelca)
poddelca=[]
for i in range(1,N+1):
    for j in range(len(mas)):
        if i not in mas[j]:
            DFS(Dict,j)
            mas.append(poddelca)
            poddelca=[]
print(mas)
